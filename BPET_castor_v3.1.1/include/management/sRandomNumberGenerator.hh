/*
This file is part of CASToR.

    CASToR is free software: you can redistribute it and/or modify it under the
    terms of the GNU General Public License as published by the Free Software
    Foundation, either version 3 of the License, or (at your option) any later
    version.

    CASToR is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
    details.

    You should have received a copy of the GNU General Public License along with
    CASToR (in file GNU_GPL.TXT). If not, see <http://www.gnu.org/licenses/>.

Copyright 2017-2021 all CASToR contributors listed below:

    --> Didier BENOIT, Claude COMTAT, Marina FILIPOVIC, Thibaut MERLIN, Mael MILLARDET, Simon STUTE, Valentin VIELZEUF, Zacharias CHALAMPALAKIS

This is CASToR version 3.1.1.
*/

/*!
  \file
  \ingroup  management
  \brief    Declaration of class sRandomNumberGenerator
*/

#ifndef SRANDOMNUMBERGENERATOR_HH
#define SRANDOMNUMBERGENERATOR_HH 1

#include "gVariables.hh"
#include "sOutputManager.hh"

/*!
  \class   sRandomNumberGenerator
  \brief   Singleton class that generate a thread-safe random generator number for openMP \n
           As singleton, it can be called from any class requiring RNGs
*/
class sRandomNumberGenerator
{
  // -------------------------------------------------------------------
  // Constructor & Destructor
  public:
    /*!
      \fn      static sRandomNumberGenerator* sRandomNumberGenerator::GetInstance()
      \brief   Instanciate the singleton object and Initialize member variables if not already done, 
               return a pointer to this object otherwise
      \return  instance of the sRandomNumberGenerator singleton
    */
    static sRandomNumberGenerator* GetInstance() 
    {
      if (mp_Instance == NULL) mp_Instance = new sRandomNumberGenerator();
      return mp_Instance;
    }


  // -------------------------------------------------------------------
  // Public member functions
  public:
    typedef mt19937 Engine; /*!< Engine using C++11 Mersenne Twister pseudo-random generator of 32-bit numbers */
    typedef uniform_real_distribution<HPFLTNB> Distribution;  /*!< Distribution which produces random floating-point values i, uniformly distributed on the interval [a, b) */
    /*!
      \fn      int sRandomNumberGenerator::Initialize(int a_nbThreads, int a_nbExtra)
      \param   a_nbThreads : number of generators intended for usage in threads (one per thread)
      \param   a_nbExtra : number of additional generators intended for other usage (not thread safe)
      \brief   Instantiate pseudo random number generators, one per thread by default, and additional extra ones if requested
      \details The generators for each thread and each MPI instance should be independent.
      The initial seed is generated by the true random generator and used to seed a temporary PRNG, 
      which generates seeds for all final PRNGs.
      If MPI is used, an additional level of temporary generators is inserted, to ensure randomness.
      \return  0 if success, positive value otherwise
    */
    int Initialize(int a_nbThreads, int a_nbExtra);
    
    /*!
      \fn int sRandomNumberGenerator::Initialize(int64_t a_seed, int a_nbThreads, int a_nbExtra)
      \param a_seed : initial seed
      \param a_nbThreads : number of generators intended for usage in threads (one per thread)
      \param a_nbExtra : number of additional generators intended for other usage (not thread safe)
      \brief Instantiate pseudo random number generators, one per thread by default, and additional extra ones if requested, starting from the user-provided seed
      \details The generators for each thread and each MPI instance should be independent.
      The user-provided seed is fed to a temporary PRNG, which generates seeds for all final PRNGs.
      If MPI is used, an additional level of temporary generators is inserted, to ensure randomness.
      \return 0 if success, positive value otherwise
    */
    int Initialize(int64_t a_seed, int a_nbThreads, int a_nbExtra);
    /*!
      \fn      HPFLTNB sRandomNumberGenerator::GenerateRdmNber()
      \brief   Generate a random number for the thread which index is recovered from the OpenMP function
      \return  a random generated number in [0. ; 1.)
      \todo    Perhaps getting the thread index from argument rather than directly from the function.
      \todo    But this implementation allows the RNG to be used anywhere in the code
      \todo    Perhaps create a random distribution on the fly, and offer the possibility to select lower/upper bounds via argument parameters
    */
    HPFLTNB GenerateRdmNber();
    /*!
      \fn      HPFLTNB sRandomNumberGenerator::GenerateExtraRdmNber(int a_nb)
      \param   a_nb: index of the extra non threaded rng
      \brief   Generate a random number using the specified additional not thread safe random generator, for use in sequential
               parts of an otherwise multithreaded code
      \return  HPFLTNB random number
    */
    HPFLTNB GenerateExtraRdmNber(int a_nb = 0);
    /*!
      \fn      Engine& sRandomNumberGenerator::GetExtraGenerator(int a_nb)
      \param   a_nb:  index of the extra non threaded rng
      \brief   Get the not thread safe additional random generator, for use various sequential
               parts of an otherwise multithreaded code
      \return  HPFLTNB random number
    */
    Engine& GetExtraGenerator(int a_nb = 0);
    /*!
      \fn      Engine& sRandomNumberGenerator::GetGenerator()
      \brief   Get the random generator for the current thread
      \return  Engine& random generator
    */
    Engine& GetGenerator();
    /*!
      \fn      void sRandomNumberGenerator::SetVerbose(int a_verboseLevel)
      \param   a_verboseLevel
      \brief   Set verbosity level
    */
    void SetVerbose(int a_verboseLevel) {m_verbose = a_verboseLevel;};


  // -------------------------------------------------------------------
  // Private member functions
  private:
    /*!
      \fn      sRandomNumberGenerator::sRandomNumberGenerator
      \brief   Constructor of sRandomNumberGenerator. Do nothing by default as it is a singleton clasee
    */
    sRandomNumberGenerator();
    /*!
      \fn      sRandomNumberGenerator::~sRandomNumberGenerator
      \brief   Destructor of sRandomNumberGenerator. Do nothing by default
    */
    ~sRandomNumberGenerator();
    // Prevent the compiler generating methods of copy the object :
    sRandomNumberGenerator(sRandomNumberGenerator const&);     
    void operator=(sRandomNumberGenerator const&);


  // -------------------------------------------------------------------
  // Data members
  private:
    static sRandomNumberGenerator* mp_Instance;  /*!< Unique instance of the singleton class */
    int m_verbose;                               /*!< Verbosity Level */
    vector<Engine> mp_Engines;                   /*!< Multithreaded of mt199937 Engines (1 by thread) */
    vector<Engine> mp_extraEngines;              /*!< Additional non threaded mt199937 Engines if requested */
    Distribution mp_Distribution;                /*!< Uniform distribution */
    int64_t m_seed;                              /*!< Initial seed, that will start the initialization process for all the final pseudo random generators */
};

#endif

